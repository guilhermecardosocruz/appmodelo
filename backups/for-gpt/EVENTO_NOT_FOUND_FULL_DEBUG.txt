
===== app/api/eventos/route.ts =====
[MISSING] app/api/eventos/route.ts

===== app/api/events/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 
4 const VALID_TYPES = ["PRE_PAGO", "POS_PAGO", "FREE"] as const;
5 type EventType = (typeof VALID_TYPES)[number];
6 
7 // GET /api/events - lista todos os eventos
8 export async function GET(_request: NextRequest) {
9   const events = await prisma.event.findMany({
10     orderBy: { createdAt: "desc" },
11   });
12 
13   return NextResponse.json(events, { status: 200 });
14 }
15 
16 // POST /api/events - cria um novo evento
17 export async function POST(request: NextRequest) {
18   try {
19     const body = await request.json();
20     const name = String(body.name ?? "").trim();
21     const type = String(body.type ?? "").toUpperCase() as EventType;
22 
23     if (!name) {
24       return NextResponse.json(
25         { error: "Nome do evento é obrigatório." },
26         { status: 400 }
27       );
28     }
29 
30     if (!VALID_TYPES.includes(type)) {
31       return NextResponse.json(
32         { error: "Tipo de evento inválido." },
33         { status: 400 }
34       );
35     }
36 
37     const event = await prisma.event.create({
38       data: {
39         name,
40         type,
41       },
42     });
43 
44     return NextResponse.json(event, { status: 201 });
45   } catch (err) {
46     console.error("Erro ao criar evento:", err);
47     return NextResponse.json(
48       { error: "Erro ao criar evento." },
49       { status: 500 }
50     );
51   }
52 }
53 
54 // PATCH /api/events - atualiza um evento existente (id no corpo)
55 export async function PATCH(request: NextRequest) {
56   try {
57     const body = await request.json();
58     const id = String(body.id ?? "").trim();
59 
60     if (!id) {
61       return NextResponse.json(
62         { error: "ID do evento é obrigatório para atualizar." },
63         { status: 400 }
64       );
65     }
66 
67     const data: {
68       name?: string;
69       description?: string | null;
70       location?: string | null;
71       inviteSlug?: string | null;
72     } = {};
73 
74     if (typeof body.name === "string") {
75       const name = body.name.trim();
76       if (!name) {
77         return NextResponse.json(
78           { error: "Nome do evento não pode ser vazio." },
79           { status: 400 }
80         );
81       }
82       data.name = name;
83     }
84 
85     if (typeof body.description === "string" || body.description === null) {
86       data.description = body.description;
87     }
88 
89     if (typeof body.location === "string" || body.location === null) {
90       data.location = body.location;
91     }
92 
93     if (typeof body.inviteSlug === "string" || body.inviteSlug === null) {
94       data.inviteSlug = body.inviteSlug;
95     }
96 
97     if (Object.keys(data).length === 0) {
98       return NextResponse.json(
99         { error: "Nenhum campo para atualizar." },
100         { status: 400 }
101       );
102     }
103 
104     const updated = await prisma.event.update({
105       where: { id },
106       data,
107     });
108 
109     return NextResponse.json(updated, { status: 200 });
110   } catch (err) {
111     console.error("Erro ao atualizar evento:", err);
112     return NextResponse.json(
113       { error: "Erro ao atualizar evento." },
114       { status: 500 }
115     );
116   }
117 }
118 
119 // DELETE /api/events - exclui um evento (id no corpo)
120 export async function DELETE(request: NextRequest) {
121   try {
122     const body = await request.json();
123     const id = String(body.id ?? "").trim();
124 
125     if (!id) {
126       return NextResponse.json(
127         { error: "ID do evento é obrigatório para excluir." },
128         { status: 400 }
129       );
130     }
131 
132     await prisma.event.delete({
133       where: { id },
134     });
135 
136     return NextResponse.json({ ok: true }, { status: 200 });
137   } catch (err) {
138     console.error("Erro ao excluir evento:", err);
139     return NextResponse.json(
140       { error: "Erro ao excluir evento." },
141       { status: 500 }
142     );
143   }
144 }

===== app/api/events/[id]/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 
4 export async function GET(_request: NextRequest, context: any) {
5   try {
6     let rawParams = context?.params as any;
7 
8     // Se o Next resolver params como Promise, tratamos isso
9     if (rawParams && typeof rawParams.then === "function") {
10       rawParams = await rawParams;
11     }
12 
13     const id = String(rawParams?.id ?? "").trim();
14     console.log("[GET /api/events/[id]] params:", rawParams, "id:", id);
15 
16     if (!id) {
17       return NextResponse.json(
18         { error: "ID do evento é obrigatório." },
19         { status: 400 }
20       );
21     }
22 
23     const event = await prisma.event.findUnique({
24       where: { id },
25     });
26 
27     if (!event) {
28       return NextResponse.json(
29         { error: "Evento não encontrado." },
30         { status: 404 }
31       );
32     }
33 
34     return NextResponse.json(event, { status: 200 });
35   } catch (err) {
36     console.error("Erro ao buscar evento por ID:", err);
37     return NextResponse.json(
38       { error: "Erro ao buscar evento." },
39       { status: 500 }
40     );
41   }
42 }

===== prisma/schema.prisma =====
1 generator client {
2   provider = "prisma-client-js"
3 }
4 
5 datasource db {
6   provider = "postgresql"
7   url      = env("DATABASE_URL")
8 }
9 
10 enum EventType {
11   PRE_PAGO
12   POS_PAGO
13   FREE
14 }
15 
16 model User {
17   id           String                @id @default(cuid())
18   name         String
19   email        String                @unique
20   passwordHash String
21   createdAt    DateTime              @default(now())
22   updatedAt    DateTime              @updatedAt
23 
24   resetTokens  PasswordResetToken[]
25 }
26 
27 model PasswordResetToken {
28   id        String   @id @default(cuid())
29   token     String   @unique
30   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
31   userId    String
32   expiresAt DateTime
33   createdAt DateTime @default(now())
34 }
35 
36 model Event {
37   id          String     @id @default(cuid())
38   name        String
39   type        EventType
40   description String?    // para eventos free (e outros) descreverem detalhes
41   location    String?    // local do evento
42   inviteSlug  String?    @unique // usado para gerar link de convite
43   createdAt   DateTime   @default(now())
44 }

===== lib/prisma.ts =====
1 import { PrismaClient } from "@prisma/client";
2 
3 const globalForPrisma = globalThis as unknown as {
4   prisma: PrismaClient | undefined;
5 };
6 
7 export const prisma =
8   globalForPrisma.prisma ??
9   new PrismaClient({
10     log: ["query", "error", "warn"],
11   });
12 
13 if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

===== lib/auth.ts =====
1 import bcrypt from "bcryptjs";
2 import { prisma } from "@/lib/prisma";
3 
4 export async function registerUser(name: string, email: string, password: string) {
5   const normalizedEmail = email.toLowerCase();
6 
7   const existing = await prisma.user.findUnique({
8     where: { email: normalizedEmail },
9   });
10 
11   if (existing) {
12     throw new Error("E-mail já cadastrado");
13   }
14 
15   const passwordHash = await bcrypt.hash(password, 10);
16 
17   const user = await prisma.user.create({
18     data: {
19       name,
20       email: normalizedEmail,
21       passwordHash,
22     },
23     select: {
24       id: true,
25       name: true,
26       email: true,
27     },
28   });
29 
30   return user;
31 }
32 
33 export async function validateLogin(email: string, password: string) {
34   const normalizedEmail = email.toLowerCase();
35 
36   const user = await prisma.user.findUnique({
37     where: { email: normalizedEmail },
38   });
39 
40   if (!user) return null;
41 
42   const ok = await bcrypt.compare(password, user.passwordHash);
43   if (!ok) return null;
44 
45   return {
46     id: user.id,
47     name: user.name,
48     email: user.email,
49   };
50 }
51 
52 export async function createResetToken(email: string) {
53   const normalizedEmail = email.toLowerCase();
54 
55   const user = await prisma.user.findUnique({
56     where: { email: normalizedEmail },
57   });
58 
59   if (!user) {
60     // Em produção, não revelamos se o e-mail existe.
61     return null;
62   }
63 
64   const token = crypto.randomUUID();
65   const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hora
66 
67   await prisma.passwordResetToken.create({
68     data: {
69       token,
70       userId: user.id,
71       expiresAt,
72     },
73   });
74 
75   return token;
76 }
77 
78 export async function resetPassword(token: string, newPassword: string) {
79   const reset = await prisma.passwordResetToken.findUnique({
80     where: { token },
81     include: { user: true },
82   });
83 
84   if (!reset) {
85     throw new Error("Token inválido ou expirado");
86   }
87 
88   if (reset.expiresAt < new Date()) {
89     await prisma.passwordResetToken.delete({
90       where: { token },
91     });
92     throw new Error("Token expirado");
93   }
94 
95   const passwordHash = await bcrypt.hash(newPassword, 10);
96 
97   const updatedUser = await prisma.user.update({
98     where: { id: reset.userId },
99     data: { passwordHash },
100     select: {
101       id: true,
102       email: true,
103     },
104   });
105 
106   await prisma.passwordResetToken.delete({
107     where: { token },
108   });
109 
110   return updatedUser;
111 }

===== lib/validation.ts =====
1 import { z } from "zod";
2 
3 export const passwordSchema = z
4   .string()
5   .min(8, "A senha deve ter no mínimo 8 caracteres")
6   .regex(/[a-z]/, "A senha deve ter pelo menos uma letra minúscula")
7   .regex(/[A-Z]/, "A senha deve ter pelo menos uma letra maiúscula")
8   .regex(/\d/, "A senha deve ter pelo menos um número")
9   .regex(
10     /[^A-Za-z0-9]/,
11     "A senha deve ter pelo menos um caractere especial (!@#$%&*, etc.)"
12   );
13 
14 export const registerSchema = z
15   .object({
16     name: z.string().min(3, "Nome muito curto"),
17     email: z.string().email("E-mail inválido"),
18     password: passwordSchema,
19     confirmPassword: z.string(),
20   })
21   .refine((data) => data.password === data.confirmPassword, {
22     path: ["confirmPassword"],
23     message: "As senhas não conferem",
24   });
25 
26 export const loginSchema = z.object({
27   email: z.string().email("E-mail inválido"),
28   password: z.string().min(1, "Informe sua senha"),
29 });
30 
31 export const recoverSchema = z.object({
32   email: z.string().email("E-mail inválido"),
33 });
34 
35 export const resetSchema = z.object({
36   token: z.string().min(1, "Token inválido"),
37   password: passwordSchema,
38 });

===== app/(app)/dashboard/DashboardClient.tsx =====
1 "use client";
2 
3 import { useEffect, useState } from "react";
4 import Link from "next/link";
5 
6 type EventType = "PRE_PAGO" | "POS_PAGO" | "FREE";
7 
8 type Event = {
9   id: string;
10   name: string;
11   type: EventType;
12   createdAt: string;
13 };
14 
15 function getTypeLabel(type: EventType) {
16   if (type === "PRE_PAGO") return "Pré pago";
17   if (type === "POS_PAGO") return "Pós pago";
18   return "Free";
19 }
20 
21 function getEventHref(event: Event) {
22   if (event.type === "PRE_PAGO") return `/eventos/${event.id}/pre`;
23   if (event.type === "POS_PAGO") return `/eventos/${event.id}/pos`;
24   return `/eventos/${event.id}/free`;
25 }
26 
27 export default function DashboardClient() {
28   const [events, setEvents] = useState<Event[]>([]);
29   const [loading, setLoading] = useState(true);
30   const [error, setError] = useState<string | null>(null);
31 
32   const [name, setName] = useState("");
33   const [type, setType] = useState<EventType>("FREE");
34   const [creating, setCreating] = useState(false);
35 
36   useEffect(() => {
37     let active = true;
38 
39     async function load() {
40       try {
41         setLoading(true);
42         setError(null);
43 
44         const res = await fetch("/api/events");
45         if (!res.ok) {
46           const data = await res.json().catch(() => null);
47           if (!active) return;
48           setError(data?.error ?? "Erro ao carregar eventos.");
49           return;
50         }
51 
52         const data = (await res.json()) as Event[];
53         if (!active) return;
54         setEvents(data);
55       } catch (err) {
56         console.error(err);
57         if (!active) return;
58         setError("Erro inesperado ao carregar eventos.");
59       } finally {
60         if (!active) return;
61         setLoading(false);
62       }
63     }
64 
65     load();
66 
67     return () => {
68       active = false;
69     };
70   }, []);
71 
72   async function handleCreate(e: React.FormEvent) {
73     e.preventDefault();
74     if (!name.trim()) {
75       setError("Informe um nome para o evento.");
76       return;
77     }
78 
79     try {
80       setCreating(true);
81       setError(null);
82 
83       const res = await fetch("/api/events", {
84         method: "POST",
85         headers: {
86           "Content-Type": "application/json",
87         },
88         body: JSON.stringify({
89           name,
90           type,
91         }),
92       });
93 
94       if (!res.ok) {
95         const data = await res.json().catch(() => null);
96         setError(data?.error ?? "Erro ao criar evento.");
97         return;
98       }
99 
100       const created = (await res.json()) as Event;
101 
102       setEvents((prev) => [created, ...prev]);
103       setName("");
104       setType("FREE");
105     } catch (err) {
106       console.error(err);
107       setError("Erro inesperado ao criar evento.");
108     } finally {
109       setCreating(false);
110     }
111   }
112 
113   async function handleDelete(id: string) {
114     try {
115       setError(null);
116 
117       const res = await fetch("/api/events", {
118         method: "DELETE",
119         headers: {
120           "Content-Type": "application/json",
121         },
122         body: JSON.stringify({ id }),
123       });
124 
125       if (!res.ok) {
126         const data = await res.json().catch(() => null);
127         setError(data?.error ?? "Erro ao excluir evento.");
128         return;
129       }
130 
131       setEvents((prev) => prev.filter((e) => e.id !== id));
132     } catch (err) {
133       console.error(err);
134       setError("Erro inesperado ao excluir evento.");
135     }
136   }
137 
138   return (
139     <div className="min-h-screen bg-slate-950 text-slate-50 flex flex-col">
140       <header className="flex items-center justify-between px-6 py-4 border-b border-slate-800">
141         <h1 className="text-lg sm:text-xl font-semibold">
142           Meus eventos
143         </h1>
144 
145         <button
146           type="button"
147           className="text-xs font-medium text-slate-300 hover:text-slate-100"
148         >
149           Sair
150         </button>
151       </header>
152 
153       <main className="flex-1 px-4 py-6 sm:px-6 lg:px-8 max-w-5xl w-full mx-auto flex flex-col gap-6">
154         {/* Form de criação */}
155         <form
156           onSubmit={handleCreate}
157           className="flex flex-col gap-3 rounded-2xl border border-slate-800 bg-slate-900/50 p-4 sm:flex-row sm:items-end sm:gap-4"
158         >
159           <div className="flex-1 flex flex-col gap-1">
160             <label className="text-xs font-medium text-slate-300">
161               Nome do evento
162             </label>
163             <input
164               type="text"
165               value={name}
166               onChange={(e) => setName(e.target.value)}
167               className="rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-50 placeholder:text-slate-500 shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500"
168               placeholder="Digite o nome do evento"
169             />
170           </div>
171 
172           <div className="w-full sm:w-40 flex flex-col gap-1">
173             <label className="text-xs font-medium text-slate-300">
174               Tipo
175             </label>
176             <select
177               value={type}
178               onChange={(e) => setType(e.target.value as EventType)}
179               className="rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-50 shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500"
180             >
181               <option value="FREE">Free</option>
182               <option value="PRE_PAGO">Pré pago</option>
183               <option value="POS_PAGO">Pós pago</option>
184             </select>
185           </div>
186 
187           <button
188             type="submit"
189             disabled={creating}
190             className="inline-flex items-center justify-center rounded-lg bg-emerald-600 px-4 py-2 text-sm font-semibold text-white shadow-sm hover:bg-emerald-500 disabled:opacity-60"
191           >
192             {creating ? "Criando..." : "Adicionar evento"}
193           </button>
194         </form>
195 
196         {error && (
197           <p className="text-sm text-red-400">
198             {error}
199           </p>
200         )}
201 
202         {loading && (
203           <p className="text-sm text-slate-300">Carregando eventos...</p>
204         )}
205 
206         {!loading && events.length === 0 && (
207           <p className="text-sm text-slate-400">
208             Nenhum evento criado ainda. Crie o primeiro acima.
209           </p>
210         )}
211 
212         {/* Grid de cards */}
213         <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
214           {events.map((event) => (
215             <div
216               key={event.id}
217               className="flex flex-col justify-between rounded-2xl border border-slate-800 bg-slate-900/60 p-4"
218             >
219               <div className="flex flex-col gap-1">
220                 <span className="text-[11px] uppercase tracking-wide text-slate-400">
221                   {getTypeLabel(event.type)}
222                 </span>
223                 <h2 className="text-sm font-semibold text-slate-50 line-clamp-2">
224                   {event.name}
225                 </h2>
226               </div>
227 
228               <div className="mt-4 flex items-center justify-between gap-2">
229                 <Link
230                   href={getEventHref(event)}
231                   className="inline-flex items-center justify-center rounded-lg bg-slate-800 px-3 py-1.5 text-xs font-medium text-slate-50 hover:bg-slate-700"
232                 >
233                   Abrir
234                 </Link>
235 
236                 <button
237                   type="button"
238                   onClick={() => handleDelete(event.id)}
239                   className="inline-flex items-center justify-center rounded-lg border border-red-600 px-3 py-1.5 text-xs font-medium text-red-400 hover:bg-red-950/50"
240                 >
241                   Excluir
242                 </button>
243               </div>
244             </div>
245           ))}
246         </div>
247       </main>
248     </div>
249   );
250 }

===== app/(app)/dashboard/page.tsx =====
1 import DashboardClient from "./DashboardClient";
2 
3 export default function DashboardPage() {
4   return <DashboardClient />;
5 }

===== app/(app)/eventos/[id]/EventTipoClient.tsx =====
1 "use client";
2 
3 import { useEffect, useState } from "react";
4 import Link from "next/link";
5 
6 type EventType = "PRE_PAGO" | "POS_PAGO" | "FREE";
7 
8 type Event = {
9   id: string;
10   name: string;
11   type: EventType;
12   description?: string | null;
13   location?: string | null;
14   createdAt?: string;
15 };
16 
17 type Mode = "free" | "pre" | "pos";
18 
19 type Props = {
20   eventId: string;
21   mode: Mode;
22 };
23 
24 function getTitle(mode: Mode) {
25   if (mode === "pre") return "Evento pré pago";
26   if (mode === "pos") return "Evento pós pago";
27   return "Evento free";
28 }
29 
30 function getDescription(mode: Mode) {
31   if (mode === "pre") {
32     return "Aqui terá a lógica do evento pré pago.";
33   }
34   if (mode === "pos") {
35     return "Aqui terá a lógica do evento pós pago.";
36   }
37   return "Aqui terá a lógica do evento free.";
38 }
39 
40 export default function EventTipoClient({ eventId, mode }: Props) {
41   const [event, setEvent] = useState<Event | null>(null);
42   const [loading, setLoading] = useState(true);
43   const [error, setError] = useState<string | null>(null);
44 
45   useEffect(() => {
46     let active = true;
47 
48     async function load() {
49       try {
50         setLoading(true);
51         setError(null);
52 
53         const trimmedId = String(eventId ?? "").trim();
54         if (!trimmedId) {
55           console.warn("[EventTipoClient] eventId vazio, abortando fetch.");
56           setError("ID do evento inválido.");
57           setEvent(null);
58           return;
59         }
60 
61         // Usa a MESMA rota do dashboard e filtra no cliente
62         console.log("[EventTipoClient] Carregando eventos de /api/events...");
63         const res = await fetch("/api/events");
64 
65         if (!res.ok) {
66           const data = await res.json().catch(() => null);
67           if (!active) return;
68 
69           setError(data?.error ?? "Erro ao carregar evento.");
70           setEvent(null);
71           return;
72         }
73 
74         const all = (await res.json()) as Event[];
75         if (!active) return;
76 
77         const found = all.find((e) => e.id === trimmedId) ?? null;
78 
79         if (!found) {
80           console.warn(
81             "[EventTipoClient] Evento não encontrado na lista.",
82             "eventId:",
83             trimmedId
84           );
85           setError("Evento não encontrado.");
86           setEvent(null);
87           return;
88         }
89 
90         setEvent(found);
91       } catch (err) {
92         console.error("[EventTipoClient] Erro no fetch:", err);
93         if (!active) return;
94         setError("Erro inesperado ao carregar evento.");
95         setEvent(null);
96       } finally {
97         if (!active) return;
98         setLoading(false);
99       }
100     }
101 
102     load();
103 
104     return () => {
105       active = false;
106     };
107   }, [eventId, mode]);
108 
109   return (
110     <div className="min-h-screen bg-slate-950 text-slate-50 flex flex-col">
111       <header className="flex items-center justify-between px-6 py-4 border-b border-slate-800">
112         <Link
113           href="/dashboard/"
114           className="text-xs font-medium text-slate-300 hover:text-slate-100"
115         >
116           ← Voltar
117         </Link>
118 
119         {event && (
120           <span className="inline-flex items-center rounded-full bg-slate-900 px-3 py-1 text-[11px] font-medium uppercase tracking-wide text-slate-300 border border-slate-700">
121             {event.type}
122           </span>
123         )}
124       </header>
125 
126       <main className="flex-1 px-4 py-6 sm:px-6 lg:px-8 max-w-3xl w-full mx-auto flex flex-col gap-4">
127         {loading && (
128           <p className="text-sm text-slate-300">Carregando evento...</p>
129         )}
130 
131         {error && !loading && (
132           <p className="text-sm text-red-400">{error}</p>
133         )}
134 
135         {!loading && !error && !event && (
136           <p className="text-sm text-slate-300">
137             Evento não encontrado.
138           </p>
139         )}
140 
141         {event && (
142           <>
143             <h1 className="text-xl sm:text-2xl font-semibold text-slate-50">
144               {event.name}
145             </h1>
146 
147             <h2 className="text-sm font-medium text-slate-200">
148               {getTitle(mode)}
149             </h2>
150 
151             <p className="text-sm text-slate-300">
152               {getDescription(mode)}
153             </p>
154 
155             <p className="mt-4 text-[11px] text-slate-500">
156               (No futuro, aqui vamos montar toda a lógica detalhada desse tipo
157               de evento: configurações, regras, integrações, fluxos, etc.)
158             </p>
159           </>
160         )}
161       </main>
162     </div>
163   );
164 }

===== app/(app)/eventos/[id]/free/page.tsx =====
1 import EventTipoClient from "../EventTipoClient";
2 
3 type PageProps = {
4   params: {
5     id: string;
6   };
7 };
8 
9 export default function EventoFreePage({ params }: PageProps) {
10   return <EventTipoClient eventId={params.id} mode="free" />;
11 }

===== app/(app)/eventos/[id]/pre/page.tsx =====
1 import EventTipoClient from "../EventTipoClient";
2 
3 type PageProps = {
4   params: {
5     id: string;
6   };
7 };
8 
9 export default function EventoPrePagoPage({ params }: PageProps) {
10   return <EventTipoClient eventId={params.id} mode="pre" />;
11 }

===== app/(app)/eventos/[id]/pos/page.tsx =====
1 import EventTipoClient from "../EventTipoClient";
2 
3 type PageProps = {
4   params: {
5     id: string;
6   };
7 };
8 
9 export default function EventoPosPagoPage({ params }: PageProps) {
10   return <EventTipoClient eventId={params.id} mode="pos" />;
11 }

===== app/layout.tsx =====
1 import type { Metadata, Viewport } from "next";
2 import "./globals.css";
3 
4 export const metadata: Metadata = {
5   title: "Auth PWA App",
6   description: "App modelo de autenticação com PWA e eventos.",
7 };
8 
9 export const viewport: Viewport = {
10   themeColor: "#020617", // bg-slate-950
11 };
12 
13 export default function RootLayout({
14   children,
15 }: {
16   children: React.ReactNode;
17 }) {
18   return (
19     <html lang="pt-BR">
20       <body className="bg-slate-950 text-slate-50 antialiased">
21         {children}
22       </body>
23     </html>
24   );
25 }

===== app/page.tsx =====
1 import Link from "next/link";
2 
3 export default function HomePage() {
4   return (
5     <main className="flex min-h-screen flex-col items-center justify-center bg-slate-950 px-4">
6       <div className="w-full max-w-md rounded-2xl bg-slate-900/80 p-8 text-center text-slate-50 shadow-xl shadow-black/50">
7         <h1 className="text-2xl font-semibold">Auth PWA App</h1>
8         <p className="mt-2 text-sm text-slate-400">
9           Autenticação moderna, responsiva e pronta para PWA.
10         </p>
11         <div className="mt-6 flex justify-center gap-3 text-sm">
12           <Link
13             href="/login"
14             className="rounded-lg bg-indigo-500 px-4 py-2 font-semibold text-white hover:bg-indigo-400"
15           >
16             Entrar
17           </Link>
18           <Link
19             href="/register"
20             className="rounded-lg border border-slate-600 px-4 py-2 font-semibold text-slate-200 hover:bg-slate-800"
21           >
22             Criar conta
23           </Link>
24         </div>
25       </div>
26     </main>
27   );
28 }
