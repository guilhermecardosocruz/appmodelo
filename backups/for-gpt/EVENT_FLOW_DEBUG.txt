
===== app/api/events/[id]/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 
4 export async function GET(_request: NextRequest, context: any) {
5   try {
6     let rawParams = context?.params as any;
7 
8     // Se o Next resolver params como Promise, tratamos isso
9     if (rawParams && typeof rawParams.then === "function") {
10       rawParams = await rawParams;
11     }
12 
13     const id = String(rawParams?.id ?? "").trim();
14     console.log("[GET /api/events/[id]] params:", rawParams, "id:", id);
15 
16     if (!id) {
17       return NextResponse.json(
18         { error: "ID do evento é obrigatório." },
19         { status: 400 }
20       );
21     }
22 
23     const event = await prisma.event.findUnique({
24       where: { id },
25     });
26 
27     if (!event) {
28       return NextResponse.json(
29         { error: "Evento não encontrado." },
30         { status: 404 }
31       );
32     }
33 
34     return NextResponse.json(event, { status: 200 });
35   } catch (err) {
36     console.error("Erro ao buscar evento por ID:", err);
37     return NextResponse.json(
38       { error: "Erro ao buscar evento." },
39       { status: 500 }
40     );
41   }
42 }

===== app/(app)/eventos/[id]/EventTipoClient.tsx =====
1 "use client";
2 
3 import { useEffect, useState } from "react";
4 import Link from "next/link";
5 import { useParams } from "next/navigation";
6 
7 type EventType = "PRE_PAGO" | "POS_PAGO" | "FREE";
8 
9 type Event = {
10   id: string;
11   name: string;
12   type: EventType;
13   description?: string | null;
14   location?: string | null;
15   createdAt?: string;
16 };
17 
18 type Mode = "free" | "pre" | "pos";
19 
20 type Props = {
21   mode: Mode;
22 };
23 
24 function getTitle(mode: Mode) {
25   if (mode === "pre") return "Evento pré pago";
26   if (mode === "pos") return "Evento pós pago";
27   return "Evento free";
28 }
29 
30 function getDescription(mode: Mode) {
31   if (mode === "pre") {
32     return "Aqui terá a lógica do evento pré pago.";
33   }
34   if (mode === "pos") {
35     return "Aqui terá a lógica do evento pós pago.";
36   }
37   return "Aqui terá a lógica do evento free.";
38 }
39 
40 export default function EventTipoClient({ mode }: Props) {
41   const params = useParams() as { id?: string };
42   const eventId = String(params?.id ?? "").trim();
43 
44   const [event, setEvent] = useState<Event | null>(null);
45   const [loading, setLoading] = useState(true);
46   const [error, setError] = useState<string | null>(null);
47 
48   useEffect(() => {
49     let active = true;
50 
51     async function load() {
52       try {
53         setLoading(true);
54         setError(null);
55 
56         console.log("[EventTipoClient] params.id:", params?.id, "eventId:", eventId);
57 
58         if (!eventId) {
59           setError("Evento não encontrado.");
60           setEvent(null);
61           return;
62         }
63 
64         console.log("[EventTipoClient] Carregando eventos de /api/events...");
65         const res = await fetch("/api/events");
66 
67         if (!res.ok) {
68           const data = await res.json().catch(() => null);
69           if (!active) return;
70 
71           setError(data?.error ?? "Erro ao carregar evento.");
72           setEvent(null);
73           return;
74         }
75 
76         const all = (await res.json()) as Event[];
77         if (!active) return;
78 
79         const found = all.find((e) => e.id === eventId) ?? null;
80 
81         if (!found) {
82           console.warn(
83             "[EventTipoClient] Evento não encontrado na lista.",
84             "eventId:",
85             eventId
86           );
87           setError("Evento não encontrado.");
88           setEvent(null);
89           return;
90         }
91 
92         setEvent(found);
93       } catch (err) {
94         console.error("[EventTipoClient] Erro no fetch:", err);
95         if (!active) return;
96         setError("Erro inesperado ao carregar evento.");
97         setEvent(null);
98       } finally {
99         if (!active) return;
100         setLoading(false);
101       }
102     }
103 
104     load();
105 
106     return () => {
107       active = false;
108     };
109     // eslint-disable-next-line react-hooks/exhaustive-deps
110   }, [eventId, mode]);
111 
112   return (
113     <div className="min-h-screen bg-slate-950 text-slate-50 flex flex-col">
114       <header className="flex items-center justify-between px-6 py-4 border-b border-slate-800">
115         <Link
116           href="/dashboard/"
117           className="text-xs font-medium text-slate-300 hover:text-slate-100"
118         >
119           ← Voltar
120         </Link>
121 
122         {event && (
123           <span className="inline-flex items-center rounded-full bg-slate-900 px-3 py-1 text-[11px] font-medium uppercase tracking-wide text-slate-300 border border-slate-700">
124             {event.type}
125           </span>
126         )}
127       </header>
128 
129       <main className="flex-1 px-4 py-6 sm:px-6 lg:px-8 max-w-3xl w-full mx-auto flex flex-col gap-4">
130         {loading && (
131           <p className="text-sm text-slate-300">Carregando evento...</p>
132         )}
133 
134         {error && !loading && (
135           <p className="text-sm text-red-400">{error}</p>
136         )}
137 
138         {!loading && !error && !event && (
139           <p className="text-sm text-slate-300">
140             Evento não encontrado.
141           </p>
142         )}
143 
144         {event && (
145           <>
146             <h1 className="text-xl sm:text-2xl font-semibold text-slate-50">
147               {event.name}
148             </h1>
149 
150             <h2 className="text-sm font-medium text-slate-200">
151               {getTitle(mode)}
152             </h2>
153 
154             <p className="text-sm text-slate-300">
155               {getDescription(mode)}
156             </p>
157 
158             <p className="mt-4 text-[11px] text-slate-500">
159               (No futuro, aqui vamos montar toda a lógica detalhada desse tipo
160               de evento: configurações, regras, integrações, fluxos, etc.)
161             </p>
162           </>
163         )}
164       </main>
165     </div>
166   );
167 }

===== app/(app)/eventos/[id]/FreeEventClient.tsx =====
1 "use client";
2 
3 import { useEffect, useState } from "react";
4 import Link from "next/link";
5 import { useParams } from "next/navigation";
6 
7 type EventType = "PRE_PAGO" | "POS_PAGO" | "FREE";
8 
9 type Event = {
10   id: string;
11   name: string;
12   type: EventType;
13   description?: string | null;
14   location?: string | null;
15   inviteSlug?: string | null;
16   eventDate?: string | null; // ISO string
17   createdAt?: string;
18 };
19 
20 type Guest = {
21   id: string;
22   name: string;
23   slug: string;
24   confirmedAt?: string | null;
25 };
26 
27 export default function FreeEventClient() {
28   const params = useParams() as { id?: string };
29   const eventId = String(params?.id ?? "").trim();
30 
31   const [loading, setLoading] = useState(true);
32   const [saving, setSaving] = useState(false);
33   const [generatingLink, setGeneratingLink] = useState(false);
34 
35   const [error, setError] = useState<string | null>(null);
36   const [success, setSuccess] = useState<string | null>(null);
37 
38   // Campos do formulário
39   const [name, setName] = useState("");
40   const [eventDate, setEventDate] = useState(""); // "YYYY-MM-DD"
41   const [description, setDescription] = useState("");
42   const [location, setLocation] = useState("");
43   const [inviteSlug, setInviteSlug] = useState<string | null>(null);
44 
45   // Lista de convidados
46   const [guests, setGuests] = useState<Guest[]>([]);
47   const [loadingGuests, setLoadingGuests] = useState(false);
48   const [guestError, setGuestError] = useState<string | null>(null);
49   const [newGuestName, setNewGuestName] = useState("");
50   const [addingGuest, setAddingGuest] = useState(false);
51 
52   useEffect(() => {
53     let active = true;
54 
55     async function load() {
56       try {
57         setLoading(true);
58         setError(null);
59         setSuccess(null);
60 
61         if (!eventId) {
62           setError("Evento não encontrado.");
63           return;
64         }
65 
66         // Carrega evento
67         const res = await fetch("/api/events");
68         if (!res.ok) {
69           const data = await res.json().catch(() => null);
70           if (!active) return;
71           setError(data?.error ?? "Erro ao carregar evento.");
72           return;
73         }
74 
75         const all = (await res.json()) as Event[];
76         if (!active) return;
77 
78         const found = all.find((e) => e.id === eventId) ?? null;
79 
80         if (!found) {
81           setError("Evento não encontrado.");
82           return;
83         }
84 
85         setName(found.name ?? "");
86         setDescription(found.description ?? "");
87         setLocation(found.location ?? "");
88         setInviteSlug(found.inviteSlug ?? null);
89 
90         if (found.eventDate) {
91           const onlyDate = found.eventDate.slice(0, 10);
92           setEventDate(onlyDate);
93         } else {
94           setEventDate("");
95         }
96 
97         // Carrega convidados
98         setLoadingGuests(true);
99         setGuestError(null);
100 
101         const guestsRes = await fetch(`/api/events/${eventId}/guests`);
102         if (!guestsRes.ok) {
103           const data = await guestsRes.json().catch(() => null);
104           if (!active) return;
105           setGuestError(
106             data?.error ?? "Erro ao carregar lista de convidados."
107           );
108         } else {
109           const data = (await guestsRes.json()) as { guests?: Guest[] };
110           if (!active) return;
111           setGuests(data.guests ?? []);
112         }
113       } catch (err) {
114         console.error("[FreeEventClient] Erro no fetch:", err);
115         if (!active) return;
116         setError("Erro inesperado ao carregar evento.");
117       } finally {
118         if (!active) return;
119         setLoading(false);
120         setLoadingGuests(false);
121       }
122     }
123 
124     load();
125 
126     return () => {
127       active = false;
128     };
129   }, [eventId]);
130 
131   async function handleSave(e: React.FormEvent) {
132     e.preventDefault();
133     if (!eventId) {
134       setError("Evento não encontrado.");
135       return;
136     }
137 
138     if (!name.trim()) {
139       setError("O nome do evento não pode ficar vazio.");
140       setSuccess(null);
141       return;
142     }
143 
144     try {
145       setSaving(true);
146       setError(null);
147       setSuccess(null);
148 
149       const res = await fetch("/api/events", {
150         method: "PATCH",
151         headers: {
152           "Content-Type": "application/json",
153         },
154         body: JSON.stringify({
155           id: eventId,
156           name: name.trim(),
157           description: description.trim() || null,
158           location: location.trim() || null,
159           eventDate: eventDate || null,
160         }),
161       });
162 
163       if (!res.ok) {
164         const data = await res.json().catch(() => null);
165         setError(data?.error ?? "Erro ao salvar alterações.");
166         return;
167       }
168 
169       setSuccess("Alterações salvas com sucesso.");
170     } catch (err) {
171       console.error("[FreeEventClient] Erro ao salvar:", err);
172       setError("Erro inesperado ao salvar alterações.");
173     } finally {
174       setSaving(false);
175     }
176   }
177 
178   async function handleGenerateInviteLink() {
179     if (!eventId) {
180       setError("Evento não encontrado.");
181       return;
182     }
183 
184     try {
185       setGeneratingLink(true);
186       setError(null);
187       setSuccess(null);
188 
189       const randomPart = Math.random().toString(36).slice(2, 8);
190       const newSlug = `${eventId.slice(0, 6)}-${randomPart}`;
191 
192       const res = await fetch("/api/events", {
193         method: "PATCH",
194         headers: {
195           "Content-Type": "application/json",
196         },
197         body: JSON.stringify({
198           id: eventId,
199           inviteSlug: newSlug,
200         }),
201       });
202 
203       if (!res.ok) {
204         const data = await res.json().catch(() => null);
205         setError(data?.error ?? "Erro ao gerar link de convite.");
206         return;
207       }
208 
209       setInviteSlug(newSlug);
210       setSuccess("Link de convite atualizado com sucesso.");
211     } catch (err) {
212       console.error("[FreeEventClient] Erro ao gerar link:", err);
213       setError("Erro inesperado ao gerar link de convite.");
214     } finally {
215       setGeneratingLink(false);
216     }
217   }
218 
219   // agora não é mais submit de form, é uma ação disparada pelo botão
220   async function handleAddGuest() {
221     if (!eventId) {
222       setGuestError("Evento não encontrado.");
223       return;
224     }
225 
226     const trimmed = newGuestName.trim();
227     if (!trimmed) {
228       setGuestError("Digite o nome do convidado antes de adicionar.");
229       return;
230     }
231 
232     try {
233       setAddingGuest(true);
234       setGuestError(null);
235 
236       const res = await fetch(`/api/events/${eventId}/guests`, {
237         method: "POST",
238         headers: {
239           "Content-Type": "application/json",
240         },
241         body: JSON.stringify({ name: trimmed }),
242       });
243 
244       if (!res.ok) {
245         const data = await res.json().catch(() => null);
246         setGuestError(data?.error ?? "Erro ao adicionar convidado.");
247         return;
248       }
249 
250       const created = (await res.json()) as Guest;
251 
252       setGuests((prev) => [...prev, created]);
253       setNewGuestName("");
254     } catch (err) {
255       console.error("[FreeEventClient] Erro ao adicionar convidado:", err);
256       setGuestError("Erro inesperado ao adicionar convidado.");
257     } finally {
258       setAddingGuest(false);
259     }
260   }
261 
262   const invitePath = inviteSlug ? `/convite/${inviteSlug}` : null;
263   const confirmedListPath = eventId ? `/eventos/${eventId}/confirmados` : null;
264 
265   // Ordena convidados por nome
266   const sortedGuests = [...guests].sort((a, b) =>
267     a.name.localeCompare(b.name, "pt-BR", { sensitivity: "base" })
268   );
269 
270   return (
271     <div className="min-h-screen bg-slate-950 text-slate-50 flex flex-col">
272       <header className="flex items-center justify-between px-6 py-4 border-b border-slate-800">
273         <Link
274           href="/dashboard/"
275           className="text-xs font-medium text-slate-300 hover:text-slate-100"
276         >
277           ← Voltar
278         </Link>
279 
280         <span className="inline-flex items-center rounded-full bg-slate-900 px-3 py-1 text-[11px] font-medium uppercase tracking-wide text-slate-300 border border-slate-700">
281           Evento free
282         </span>
283       </header>
284 
285       <main className="flex-1 px-4 py-6 sm:px-6 lg:px-8 max-w-3xl w-full mx-auto flex flex-col gap-4">
286         {loading && (
287           <p className="text-sm text-slate-300">Carregando evento...</p>
288         )}
289 
290         {!loading && error && (
291           <p className="text-sm text-red-400">{error}</p>
292         )}
293 
294         {!loading && !error && (
295           <form
296             onSubmit={handleSave}
297             className="flex flex-col gap-4 rounded-2xl border border-slate-800 bg-slate-900/70 p-4 sm:p-6"
298           >
299             <h1 className="text-lg sm:text-xl font-semibold text-slate-50">
300               Configurações do evento free
301             </h1>
302 
303             {success && (
304               <p className="text-xs text-emerald-400">
305                 {success}
306               </p>
307             )}
308 
309             {/* Nome */}
310             <div className="flex flex-col gap-1">
311               <label className="text-xs font-medium text-slate-300">
312                 Nome do evento
313               </label>
314               <input
315                 type="text"
316                 value={name}
317                 onChange={(e) => setName(e.target.value)}
318                 className="rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-50 placeholder:text-slate-500 shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500"
319                 placeholder="Digite o nome do evento"
320               />
321             </div>
322 
323             {/* Data do evento */}
324             <div className="flex flex-col gap-1">
325               <label className="text-xs font-medium text-slate-300">
326                 Data do evento
327               </label>
328               <input
329                 type="date"
330                 value={eventDate}
331                 onChange={(e) => setEventDate(e.target.value)}
332                 className="rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-50 placeholder:text-slate-500 shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500"
333               />
334               <p className="text-[10px] text-slate-500">
335                 Essa data é salva junto com o evento.
336               </p>
337             </div>
338 
339             {/* Descrição */}
340             <div className="flex flex-col gap-1">
341               <label className="text-xs font-medium text-slate-300">
342                 Descrição do evento
343               </label>
344               <textarea
345                 value={description}
346                 onChange={(e) => setDescription(e.target.value)}
347                 rows={4}
348                 className="rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-50 placeholder:text-slate-500 shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500 resize-y"
349                 placeholder="Descreva brevemente o evento, público alvo, regras, etc."
350               />
351             </div>
352 
353             {/* Link para convite aberto */}
354             <div className="flex flex-col gap-2 rounded-xl border border-slate-800 bg-slate-950/60 p-3">
355               <div className="flex items-center justify-between gap-2">
356                 <span className="text-xs font-medium text-slate-300">
357                   Link de convite aberto
358                 </span>
359 
360                 <button
361                   type="button"
362                   disabled={generatingLink}
363                   onClick={handleGenerateInviteLink}
364                   className="inline-flex items-center justify-center rounded-lg bg-emerald-600 px-3 py-1.5 text-[11px] font-semibold text-white shadow-sm hover:bg-emerald-500 disabled:opacity-60"
365                 >
366                   {generatingLink
367                     ? "Gerando..."
368                     : inviteSlug
369                     ? "Gerar novo link"
370                     : "Gerar link de convite"}
371                 </button>
372               </div>
373 
374               {inviteSlug && invitePath && (
375                 <div className="flex flex-col gap-1">
376                   <Link
377                     href={invitePath}
378                     className="truncate text-xs text-emerald-400 hover:text-emerald-300 underline-offset-2 hover:underline"
379                   >
380                     {invitePath}
381                   </Link>
382                   <p className="text-[10px] text-slate-500">
383                     Esse link abre a tela de confirmação genérica. Qualquer
384                     pessoa com o link pode confirmar presença.
385                   </p>
386                 </div>
387               )}
388 
389               {!inviteSlug && (
390                 <p className="text-[11px] text-slate-500">
391                   Nenhum link gerado ainda. Clique em &quot;Gerar link de
392                   convite&quot; para criar um link único deste evento.
393                 </p>
394               )}
395             </div>
396 
397             {/* Lista de confirmados (link aberto) */}
398             <div className="flex flex-col gap-2 rounded-xl border border-slate-800 bg-slate-950/60 p-3">
399               <div className="flex items-center justify-between gap-2">
400                 <span className="text-xs font-medium text-slate-300">
401                   Lista de confirmados (link aberto)
402                 </span>
403 
404                 {confirmedListPath && (
405                   <Link
406                     href={confirmedListPath}
407                     className="inline-flex items-center justify-center rounded-lg border border-slate-600 px-3 py-1.5 text-[11px] font-semibold text-slate-100 hover:bg-slate-800/80"
408                   >
409                     Ver lista
410                   </Link>
411                 )}
412               </div>
413               <p className="text-[11px] text-slate-400">
414                 Essa lista mostra todas as pessoas que confirmaram presença a
415                 partir do link aberto de convite.
416               </p>
417             </div>
418 
419             {/* Lista de convidados nomeados */}
420             <div className="flex flex-col gap-3 rounded-2xl border border-slate-800 bg-slate-950/80 p-3 sm:p-4">
421               <div className="flex items-center justify-between gap-2">
422                 <h2 className="text-sm font-semibold text-slate-50">
423                   Lista de convidados
424                 </h2>
425                 {loadingGuests && (
426                   <span className="text-[11px] text-slate-400">
427                     Carregando convidados...
428                   </span>
429                 )}
430               </div>
431 
432               {/* Campo para adicionar convidado (sem form aninhado) */}
433               <div className="flex flex-col sm:flex-row gap-2">
434                 <input
435                   type="text"
436                   value={newGuestName}
437                   onChange={(e) => setNewGuestName(e.target.value)}
438                   onKeyDown={(e) => {
439                     if (e.key === "Enter") {
440                       e.preventDefault();
441                       handleAddGuest();
442                     }
443                   }}
444                   className="flex-1 rounded-lg border border-slate-700 bg-slate-950 px-3 py-2 text-sm text-slate-50 placeholder:text-slate-500 shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500"
445                   placeholder="Nome do convidado (ex: João Silva)"
446                   disabled={addingGuest}
447                 />
448                 <button
449                   type="button"
450                   disabled={addingGuest}
451                   onClick={handleAddGuest}
452                   className="inline-flex items-center justify-center rounded-lg bg-emerald-600 px-4 py-2 text-sm font-semibold text-white shadow-sm hover:bg-emerald-500 disabled:opacity-60"
453                 >
454                   {addingGuest ? "Adicionando..." : "Adicionar convidado"}
455                 </button>
456               </div>
457 
458               {/* Mensagens logo abaixo do campo */}
459               {guestError && (
460                 <p className="text-[11px] text-red-400">
461                   {guestError}
462                 </p>
463               )}
464 
465               {!loadingGuests && !sortedGuests.length && !guestError && (
466                 <p className="text-[11px] text-slate-500">
467                   Nenhum convidado adicionado ainda. Comece adicionando nomes
468                   acima para gerar links de convite individuais.
469                 </p>
470               )}
471 
472               {/* Lista em ordem alfabética */}
473               {sortedGuests.length > 0 && (
474                 <div className="mt-1 space-y-2">
475                   <p className="text-[11px] text-slate-400">
476                     Os convidados abaixo estão ordenados por nome. Quem ainda
477                     não confirmou tem um link exclusivo de convite.
478                   </p>
479 
480                   <ul className="divide-y divide-slate-800">
481                     {sortedGuests.map((guest, index) => {
482                       const guestPath = guest.slug
483                         ? `/convite/pessoa/${guest.slug}`
484                         : null;
485                       const isConfirmed = !!guest.confirmedAt;
486 
487                       return (
488                         <li
489                           key={guest.id}
490                           className="py-2 flex flex-col gap-1"
491                         >
492                           <div className="flex items-center justify-between gap-2">
493                             <div className="flex items-center gap-3">
494                               <span className="w-6 text-[11px] text-slate-500">
495                                 #{index + 1}
496                               </span>
497                               <span className="text-sm text-slate-50">
498                                 {guest.name}
499                               </span>
500                             </div>
501                             <span className="text-[11px]">
502                               {isConfirmed ? (
503                                 <span className="text-emerald-400">
504                                   Confirmado
505                                 </span>
506                               ) : (
507                                 <span className="text-slate-400">
508                                   Pendente
509                                 </span>
510                               )}
511                             </span>
512                           </div>
513 
514                           {/* Link só para quem ainda não confirmou */}
515                           {!isConfirmed && guestPath && (
516                             <Link
517                               href={guestPath}
518                               className="text-[11px] text-emerald-400 hover:text-emerald-300 underline-offset-2 hover:underline break-all"
519                             >
520                               {guestPath}
521                             </Link>
522                           )}
523                         </li>
524                       );
525                     })}
526                   </ul>
527                 </div>
528               )}
529             </div>
530 
531             <div className="flex justify-end">
532               <button
533                 type="submit"
534                 disabled={saving}
535                 className="inline-flex items-center justify-center rounded-lg bg-emerald-600 px-4 py-2 text-sm font-semibold text-white shadow-sm hover:bg-emerald-500 disabled:opacity-60"
536               >
537                 {saving ? "Salvando..." : "Salvar alterações"}
538               </button>
539             </div>
540           </form>
541         )}
542       </main>
543     </div>
544   );
545 }

===== app/(app)/eventos/[id]/free/page.tsx =====
1 import FreeEventClient from "../FreeEventClient";
2 
3 export default function EventoFreePage() {
4   return <FreeEventClient />;
5 }

===== prisma/schema.prisma =====
1 generator client {
2   provider = "prisma-client-js"
3 }
4 
5 datasource db {
6   provider = "postgresql"
7   url      = env("DATABASE_URL")
8 }
9 
10 enum EventType {
11   PRE_PAGO
12   POS_PAGO
13   FREE
14 }
15 
16 model User {
17   id           String                @id @default(cuid())
18   name         String
19   email        String                @unique
20   passwordHash String
21   createdAt    DateTime              @default(now())
22   updatedAt    DateTime              @updatedAt
23 
24   resetTokens  PasswordResetToken[]
25 }
26 
27 model PasswordResetToken {
28   id        String   @id @default(cuid())
29   token     String   @unique
30   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
31   userId    String
32   expiresAt DateTime
33   createdAt DateTime @default(now())
34 }
35 
36 model Event {
37   id             String              @id @default(cuid())
38   name           String
39   type           EventType
40   description    String?             // para eventos free (e outros) descreverem detalhes
41   location       String?             // local do evento
42   inviteSlug     String?             @unique // usado para gerar link de convite
43   eventDate      DateTime?           // data do evento (opcional)
44   createdAt      DateTime            @default(now())
45 
46   // confirmações "genéricas" (link aberto)
47   confirmations  EventConfirmation[]
48 
49   // NOVO: convidados nomeados com link individual
50   guests         EventGuest[]
51 }
52 
53 model EventConfirmation {
54   id        String   @id @default(cuid())
55   event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
56   eventId   String
57   name      String
58   createdAt DateTime @default(now())
59 }
60 
61 model EventGuest {
62   id          String   @id @default(cuid())
63   event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
64   eventId     String
65   name        String
66   slug        String   @unique
67   createdAt   DateTime @default(now())
68   confirmedAt DateTime?
69 }

===== lib/validation.ts =====
1 import { z } from "zod";
2 
3 export const passwordSchema = z
4   .string()
5   .min(8, "A senha deve ter no mínimo 8 caracteres")
6   .regex(/[a-z]/, "A senha deve ter pelo menos uma letra minúscula")
7   .regex(/[A-Z]/, "A senha deve ter pelo menos uma letra maiúscula")
8   .regex(/\d/, "A senha deve ter pelo menos um número")
9   .regex(
10     /[^A-Za-z0-9]/,
11     "A senha deve ter pelo menos um caractere especial (!@#$%&*, etc.)"
12   );
13 
14 export const registerSchema = z
15   .object({
16     name: z.string().min(3, "Nome muito curto"),
17     email: z.string().email("E-mail inválido"),
18     password: passwordSchema,
19     confirmPassword: z.string(),
20   })
21   .refine((data) => data.password === data.confirmPassword, {
22     path: ["confirmPassword"],
23     message: "As senhas não conferem",
24   });
25 
26 export const loginSchema = z.object({
27   email: z.string().email("E-mail inválido"),
28   password: z.string().min(1, "Informe sua senha"),
29 });
30 
31 export const recoverSchema = z.object({
32   email: z.string().email("E-mail inválido"),
33 });
34 
35 export const resetSchema = z.object({
36   token: z.string().min(1, "Token inválido"),
37   password: passwordSchema,
38 });

===== app/api/events/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 
4 const VALID_TYPES = ["PRE_PAGO", "POS_PAGO", "FREE"] as const;
5 type EventType = (typeof VALID_TYPES)[number];
6 
7 // GET /api/events - lista todos os eventos
8 export async function GET(_request: NextRequest) {
9   const events = await prisma.event.findMany({
10     orderBy: { createdAt: "desc" },
11   });
12 
13   return NextResponse.json(events, { status: 200 });
14 }
15 
16 // POST /api/events - cria um novo evento
17 export async function POST(request: NextRequest) {
18   try {
19     const body = await request.json();
20     const name = String(body.name ?? "").trim();
21     const type = String(body.type ?? "").toUpperCase() as EventType;
22 
23     if (!name) {
24       return NextResponse.json(
25         { error: "Nome do evento é obrigatório." },
26         { status: 400 }
27       );
28     }
29 
30     if (!VALID_TYPES.includes(type)) {
31       return NextResponse.json(
32         { error: "Tipo de evento inválido." },
33         { status: 400 }
34       );
35     }
36 
37     const event = await prisma.event.create({
38       data: {
39         name,
40         type,
41       },
42     });
43 
44     return NextResponse.json(event, { status: 201 });
45   } catch (err) {
46     console.error("Erro ao criar evento:", err);
47     return NextResponse.json(
48       { error: "Erro ao criar evento." },
49       { status: 500 }
50     );
51   }
52 }
53 
54 // PATCH /api/events - atualiza um evento existente (id no corpo)
55 export async function PATCH(request: NextRequest) {
56   try {
57     const body = await request.json();
58     const id = String(body.id ?? "").trim();
59 
60     if (!id) {
61       return NextResponse.json(
62         { error: "ID do evento é obrigatório para atualizar." },
63         { status: 400 }
64       );
65     }
66 
67     const data: {
68       name?: string;
69       description?: string | null;
70       location?: string | null;
71       inviteSlug?: string | null;
72       eventDate?: Date | null;
73     } = {};
74 
75     if (typeof body.name === "string") {
76       const name = body.name.trim();
77       if (!name) {
78         return NextResponse.json(
79           { error: "Nome do evento não pode ser vazio." },
80           { status: 400 }
81         );
82       }
83       data.name = name;
84     }
85 
86     if (typeof body.description === "string" || body.description === null) {
87       data.description = body.description;
88     }
89 
90     if (typeof body.location === "string" || body.location === null) {
91       data.location = body.location;
92     }
93 
94     if (typeof body.inviteSlug === "string" || body.inviteSlug === null) {
95       data.inviteSlug = body.inviteSlug;
96     }
97 
98     // Trata eventDate vindo da tela free (string "YYYY-MM-DD" ou null)
99     if (typeof body.eventDate === "string" || body.eventDate === null) {
100       if (!body.eventDate) {
101         data.eventDate = null;
102       } else {
103         const d = new Date(body.eventDate);
104         if (Number.isNaN(d.getTime())) {
105           return NextResponse.json(
106             { error: "Data do evento inválida." },
107             { status: 400 }
108           );
109         }
110         data.eventDate = d;
111       }
112     }
113 
114     if (Object.keys(data).length === 0) {
115       return NextResponse.json(
116         { error: "Nenhum campo para atualizar." },
117         { status: 400 }
118       );
119     }
120 
121     const updated = await prisma.event.update({
122       where: { id },
123       data,
124     });
125 
126     return NextResponse.json(updated, { status: 200 });
127   } catch (err) {
128     console.error("Erro ao atualizar evento:", err);
129     return NextResponse.json(
130       { error: "Erro ao atualizar evento." },
131       { status: 500 }
132     );
133   }
134 }
135 
136 // DELETE /api/events - exclui um evento (id no corpo)
137 export async function DELETE(request: NextRequest) {
138   try {
139     const body = await request.json();
140     const id = String(body.id ?? "").trim();
141 
142     if (!id) {
143       return NextResponse.json(
144         { error: "ID do evento é obrigatório para excluir." },
145         { status: 400 }
146       );
147     }
148 
149     await prisma.event.delete({
150       where: { id },
151     });
152 
153     return NextResponse.json({ ok: true }, { status: 200 });
154   } catch (err) {
155     console.error("Erro ao excluir evento:", err);
156     return NextResponse.json(
157       { error: "Erro ao excluir evento." },
158       { status: 500 }
159     );
160   }
161 }
