
===== app/(app)/eventos/[id]/confirmados/page.tsx =====
1 import Link from "next/link";
2 
3 type PageProps = {
4   params: {
5     id: string;
6   };
7 };
8 
9 export default function EventoConfirmadosPage({ params }: PageProps) {
10   const { id } = params;
11 
12   return (
13     <div className="min-h-screen bg-slate-950 text-slate-50 flex flex-col">
14       <header className="flex items-center justify-between px-6 py-4 border-b border-slate-800">
15         <Link
16           href={`/eventos/${id}/free`}
17           className="text-xs font-medium text-slate-300 hover:text-slate-100"
18         >
19           ← Voltar para o evento
20         </Link>
21 
22         <h1 className="text-sm sm:text-base font-semibold">
23           Lista de confirmados
24         </h1>
25       </header>
26 
27       <main className="flex-1 px-4 py-6 sm:px-6 lg:px-8 max-w-3xl w-full mx-auto flex flex-col gap-4">
28         <div className="rounded-2xl border border-slate-800 bg-slate-900/70 p-4 sm:p-6">
29           <h2 className="text-sm font-semibold text-slate-50 mb-2">
30             Confirmados neste evento
31           </h2>
32           <p className="text-sm text-slate-300">
33             Aqui terá a lista de pessoas que confirmaram presença para este
34             evento.
35           </p>
36           <p className="mt-2 text-[11px] text-slate-500">
37             No futuro, esta lista será preenchida automaticamente conforme as
38             pessoas confirmarem presença através do link de convite.
39           </p>
40         </div>
41       </main>
42     </div>
43   );
44 }

===== app/api/events/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 
4 const VALID_TYPES = ["PRE_PAGO", "POS_PAGO", "FREE"] as const;
5 type EventType = (typeof VALID_TYPES)[number];
6 
7 // GET /api/events - lista todos os eventos
8 export async function GET(_request: NextRequest) {
9   const events = await prisma.event.findMany({
10     orderBy: { createdAt: "desc" },
11   });
12 
13   return NextResponse.json(events, { status: 200 });
14 }
15 
16 // POST /api/events - cria um novo evento
17 export async function POST(request: NextRequest) {
18   try {
19     const body = await request.json();
20     const name = String(body.name ?? "").trim();
21     const type = String(body.type ?? "").toUpperCase() as EventType;
22 
23     if (!name) {
24       return NextResponse.json(
25         { error: "Nome do evento é obrigatório." },
26         { status: 400 }
27       );
28     }
29 
30     if (!VALID_TYPES.includes(type)) {
31       return NextResponse.json(
32         { error: "Tipo de evento inválido." },
33         { status: 400 }
34       );
35     }
36 
37     const event = await prisma.event.create({
38       data: {
39         name,
40         type,
41       },
42     });
43 
44     return NextResponse.json(event, { status: 201 });
45   } catch (err) {
46     console.error("Erro ao criar evento:", err);
47     return NextResponse.json(
48       { error: "Erro ao criar evento." },
49       { status: 500 }
50     );
51   }
52 }
53 
54 // PATCH /api/events - atualiza um evento existente (id no corpo)
55 export async function PATCH(request: NextRequest) {
56   try {
57     const body = await request.json();
58     const id = String(body.id ?? "").trim();
59 
60     if (!id) {
61       return NextResponse.json(
62         { error: "ID do evento é obrigatório para atualizar." },
63         { status: 400 }
64       );
65     }
66 
67     const data: {
68       name?: string;
69       description?: string | null;
70       location?: string | null;
71       inviteSlug?: string | null;
72       eventDate?: Date | null;
73     } = {};
74 
75     if (typeof body.name === "string") {
76       const name = body.name.trim();
77       if (!name) {
78         return NextResponse.json(
79           { error: "Nome do evento não pode ser vazio." },
80           { status: 400 }
81         );
82       }
83       data.name = name;
84     }
85 
86     if (typeof body.description === "string" || body.description === null) {
87       data.description = body.description;
88     }
89 
90     if (typeof body.location === "string" || body.location === null) {
91       data.location = body.location;
92     }
93 
94     if (typeof body.inviteSlug === "string" || body.inviteSlug === null) {
95       data.inviteSlug = body.inviteSlug;
96     }
97 
98     // Trata eventDate vindo da tela free (string "YYYY-MM-DD" ou null)
99     if (typeof body.eventDate === "string" || body.eventDate === null) {
100       if (!body.eventDate) {
101         data.eventDate = null;
102       } else {
103         const d = new Date(body.eventDate);
104         if (Number.isNaN(d.getTime())) {
105           return NextResponse.json(
106             { error: "Data do evento inválida." },
107             { status: 400 }
108           );
109         }
110         data.eventDate = d;
111       }
112     }
113 
114     if (Object.keys(data).length === 0) {
115       return NextResponse.json(
116         { error: "Nenhum campo para atualizar." },
117         { status: 400 }
118       );
119     }
120 
121     const updated = await prisma.event.update({
122       where: { id },
123       data,
124     });
125 
126     return NextResponse.json(updated, { status: 200 });
127   } catch (err) {
128     console.error("Erro ao atualizar evento:", err);
129     return NextResponse.json(
130       { error: "Erro ao atualizar evento." },
131       { status: 500 }
132     );
133   }
134 }
135 
136 // DELETE /api/events - exclui um evento (id no corpo)
137 export async function DELETE(request: NextRequest) {
138   try {
139     const body = await request.json();
140     const id = String(body.id ?? "").trim();
141 
142     if (!id) {
143       return NextResponse.json(
144         { error: "ID do evento é obrigatório para excluir." },
145         { status: 400 }
146       );
147     }
148 
149     await prisma.event.delete({
150       where: { id },
151     });
152 
153     return NextResponse.json({ ok: true }, { status: 200 });
154   } catch (err) {
155     console.error("Erro ao excluir evento:", err);
156     return NextResponse.json(
157       { error: "Erro ao excluir evento." },
158       { status: 500 }
159     );
160   }
161 }

===== app/api/events/[id]/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 
4 export async function GET(_request: NextRequest, context: any) {
5   try {
6     let rawParams = context?.params as any;
7 
8     // Se o Next resolver params como Promise, tratamos isso
9     if (rawParams && typeof rawParams.then === "function") {
10       rawParams = await rawParams;
11     }
12 
13     const id = String(rawParams?.id ?? "").trim();
14     console.log("[GET /api/events/[id]] params:", rawParams, "id:", id);
15 
16     if (!id) {
17       return NextResponse.json(
18         { error: "ID do evento é obrigatório." },
19         { status: 400 }
20       );
21     }
22 
23     const event = await prisma.event.findUnique({
24       where: { id },
25     });
26 
27     if (!event) {
28       return NextResponse.json(
29         { error: "Evento não encontrado." },
30         { status: 404 }
31       );
32     }
33 
34     return NextResponse.json(event, { status: 200 });
35   } catch (err) {
36     console.error("Erro ao buscar evento por ID:", err);
37     return NextResponse.json(
38       { error: "Erro ao buscar evento." },
39       { status: 500 }
40     );
41   }
42 }

===== prisma/schema.prisma =====
1 generator client {
2   provider = "prisma-client-js"
3 }
4 
5 datasource db {
6   provider = "postgresql"
7   url      = env("DATABASE_URL")
8 }
9 
10 enum EventType {
11   PRE_PAGO
12   POS_PAGO
13   FREE
14 }
15 
16 model User {
17   id           String                @id @default(cuid())
18   name         String
19   email        String                @unique
20   passwordHash String
21   createdAt    DateTime              @default(now())
22   updatedAt    DateTime              @updatedAt
23 
24   resetTokens  PasswordResetToken[]
25 }
26 
27 model PasswordResetToken {
28   id        String   @id @default(cuid())
29   token     String   @unique
30   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
31   userId    String
32   expiresAt DateTime
33   createdAt DateTime @default(now())
34 }
35 
36 model Event {
37   id          String     @id @default(cuid())
38   name        String
39   type        EventType
40   description String?    // para eventos free (e outros) descreverem detalhes
41   location    String?    // local do evento
42   inviteSlug  String?    @unique // usado para gerar link de convite
43   eventDate   DateTime?  // data do evento (opcional)
44   createdAt   DateTime   @default(now())
45 }
