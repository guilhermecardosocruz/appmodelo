generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL")
}

enum EventType {
  PRE_PAGO
  POS_PAGO
  FREE
}

enum UserRole {
  USER
  ADMIN
}

model User {
  id           String   @id @default(cuid())
  name         String
  email        String   @unique
  passwordHash String
  /// ✅ identificador da conta Google (login social)
  googleId     String?  @unique
  /// ✅ identificador da conta Apple (login social)
  appleId      String?  @unique
  pixKey       String?  // ✅ chave PIX opcional
  role         UserRole @default(USER)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  resetTokens PasswordResetToken[]

  payments           Payment[]
  ledgerEntries      LedgerEntry[]
  withdrawalRequests WithdrawalRequest[]

  tickets Ticket[]

  /// ➜ eventos criados por este usuário (organizador)
  events Event[]

  /// ➜ participantes vinculados a este usuário no módulo pós-pago
  postParticipants PostEventParticipant[]

  /// ✅ eventos ocultados no dashboard (lixeira pessoal)
  hiddenEvents HiddenEvent[]

  /// ✅ convites de eventos free vinculados a este usuário
  guestInvites EventGuest[]
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Event {
  id          String    @id @default(cuid())
  name        String
  type        EventType
  description String?
  location    String?
  latitude    Float?
  longitude   Float?
  inviteSlug  String?   @unique
  eventDate   DateTime?
  /// Flag que indica se o racha/evento POS_PAGO foi encerrado
  isClosed    Boolean   @default(false)

  ticketPrice String?
  paymentLink String?
  salesStart  DateTime?
  salesEnd    DateTime?

  createdAt DateTime @default(now())

  /// ✅ Lixeira (soft delete do evento)
  deletedAt DateTime?
  /// ✅ Data limite para purge automático (deletedAt + 30 dias)
  purgeAt   DateTime?

  /// ➜ DONO do evento (organizador)
  /// opcional para não quebrar eventos antigos; novos sempre terão um organizerId
  organizerId String?
  organizer   User?   @relation(fields: [organizerId], references: [id])

  confirmations EventConfirmation[]
  guests        EventGuest[]
  payments      Payment[]
  tickets       Ticket[]

  /// ➜ módulo pós-pago (racha entre amigos)
  postParticipants PostEventParticipant[]
  postExpenses     PostEventExpense[]
  postPayments     PostEventPayment[]

  /// ✅ ocultações no dashboard (por usuário)
  hiddenBy HiddenEvent[]

  @@index([organizerId])
  @@index([deletedAt])
  @@index([purgeAt])
}

model HiddenEvent {
  id       String   @id @default(cuid())
  userId   String
  eventId  String
  hiddenAt DateTime @default(now())
  purgeAt  DateTime?

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([purgeAt])
  @@index([eventId])
}

model EventConfirmation {
  id        String   @id @default(cuid())
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId   String
  name      String
  createdAt DateTime @default(now())
}

model EventGuest {
  id          String    @id @default(cuid())
  event       Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId     String
  name        String
  slug        String    @unique
  createdAt   DateTime  @default(now())
  confirmedAt DateTime?

  /// ✅ usuário convidado (quando adicionado via busca "somente quem já tem conta")
  userId String?
  user   User? @relation(fields: [userId], references: [id])

  // ✅ 1 convidado -> 1 ticket (quando vinculado a algum usuário logado)
  ticket Ticket? @relation("GuestTicket")

  @@index([userId])
}

model Payment {
  id          String        @id @default(cuid())
  eventId     String
  organizerId String
  amount      Decimal       @db.Decimal(10, 2)
  status      PaymentStatus @default(PENDING)
  mpPaymentId String?
  externalRef String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  event         Event         @relation(fields: [eventId], references: [id])
  organizer     User          @relation(fields: [organizerId], references: [id])
  ledgerEntries LedgerEntry[]
}

enum PaymentStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

model LedgerEntry {
  id          String     @id @default(cuid())
  organizerId String
  paymentId   String?
  type        LedgerType
  amount      Decimal    @db.Decimal(10, 2)
  createdAt   DateTime   @default(now())

  organizer User     @relation(fields: [organizerId], references: [id])
  payment   Payment? @relation(fields: [paymentId], references: [id])
}

enum LedgerType {
  CREDIT
  DEBIT
}

model WithdrawalRequest {
  id          String           @id @default(cuid())
  organizerId String
  amount      Decimal          @db.Decimal(10, 2)
  status      WithdrawalStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  processedAt DateTime?

  organizer User @relation(fields: [organizerId], references: [id])
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  REJECTED
}

model Ticket {
  id           String       @id @default(cuid())
  eventId      String
  userId       String
  attendeeName String?
  status       TicketStatus @default(ACTIVE)
  createdAt    DateTime     @default(now())
  checkedInAt  DateTime?

  // ✅ vínculo opcional com EventGuest (1-1)
  guestId String?     @unique
  guest   EventGuest? @relation("GuestTicket", fields: [guestId], references: [id], onDelete: SetNull)

  event Event @relation(fields: [eventId], references: [id])
  user  User  @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([eventId])
}

enum TicketStatus {
  ACTIVE
  CANCELLED
}

/// Participante de um evento pós-pago (ex: amigo que entra na conta do bar)
model PostEventParticipant {
  id        String   @id @default(cuid())
  eventId   String
  /// Usuário dono deste participante (quando vinculado a uma conta)
  userId    String?
  /// Nome exibido no racha (pode ser o nome do usuário ou apelido)
  name      String
  /// Flag de soft delete: se false, o participante saiu do racha
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id])

  /// vínculo opcional com usuário do sistema
  user User? @relation(fields: [userId], references: [id])

  /// despesas em que este participante foi o pagador
  expensesPaid PostEventExpense[] @relation("PostPayerExpenses")

  /// cotas de despesas em que este participante entrou na divisão
  shares PostEventExpenseShare[]

  /// pagamentos deste participante no racha (via Zoop, etc.)
  payments PostEventPayment[]

  /// Garante no máximo 1 participante por usuário em cada evento pós-pago
  @@unique([eventId, userId])
}

/// Despesa lançada no evento pós-pago (ex: pizza, uber, mercado)
model PostEventExpense {
  id          String   @id @default(cuid())
  eventId     String
  payerId     String
  description String
  totalAmount Decimal  @db.Decimal(10, 2)
  createdAt   DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id])

  /// quem pagou originalmente essa despesa
  payer PostEventParticipant @relation("PostPayerExpenses", fields: [payerId], references: [id])

  /// cotas de quem topou dividir esta despesa
  shares PostEventExpenseShare[]
}

/// Cota de um participante em uma despesa
model PostEventExpenseShare {
  id            String  @id @default(cuid())
  expenseId     String
  participantId String
  shareAmount   Decimal @db.Decimal(10, 2)

  expense     PostEventExpense     @relation(fields: [expenseId], references: [id])
  participant PostEventParticipant @relation(fields: [participantId], references: [id])

  @@index([participantId])
  @@index([expenseId])
}

enum PostEventPaymentStatus {
  PENDING
  PAID
  FAILED
  CANCELLED
}

/// Pagamento de acerto de contas do racha (POS_PAGO)
model PostEventPayment {
  id                String                 @id @default(cuid())
  eventId           String
  participantId     String
  amount            Decimal                @db.Decimal(10, 2)
  status            PostEventPaymentStatus @default(PENDING)
  provider          String? // Ex.: "ZOOP"
  providerPaymentId String?
  providerPayload   Json?
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt

  event       Event                @relation(fields: [eventId], references: [id])
  participant PostEventParticipant @relation(fields: [participantId], references: [id])

  @@index([eventId])
  @@index([participantId])
}
